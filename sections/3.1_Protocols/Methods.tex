\subsection{Methods}
\label{Protocols_Methods}

The implemented pipeline consists of 10 distinct steps to process, harmonize and integrate bioactivity data into the CC universe of small molecule signatures. Steps 1-3 are preliminary and identical across all presented tasks. Steps 4-10 are generally common to all tasks but require slight fine-tuning to specify the location of the input data and the name of the new CC bioactivity space.

\paragraph{1. Installing the Chemical Checker} \leavevmode

The installation of the CC in a local computer is carried out following the instructions provided in: \\

\begin{lstlisting}
https://gitlabsbnb.irbbarcelona.org/packages/chemical_checker/-/tree/master
\end{lstlisting}

In short, we need to i) install Singularity (version>3.6), ii) clone the CC repository to a local directory and iii) run the setup script (\textit{sudo} permissions are needed).

i) Install Singularity: \\

\begin{lstlisting}
$ sudo apt-get update && sudo apt-get install -y \
     build-essential \
     uuid-dev \
     libgpgme-dev \
     squashfs-tools \
     libseccomp-dev \
     wget \
     pkg-config \
     git \
     cryptsetup-bin\
     golang-go

 $ export VERSION=3.8.0 && \
     wget https://github.com/sylabs/singularity/releases/download/v${VERSION}/singularity-ce-${VERSION}.tar.gz && \
     tar -xzf singularity-ce-${VERSION}.tar.gz && \
     cd singularity-ce-${VERSION}

 $ ./mconfig && \
     make -C ./builddir && \
     sudo make -C ./builddir install
\end{lstlisting}

ii) Cloning the CC repository to a local directory: \\

\begin{lstlisting}
cd ~ && mkdir -p cc && cd cc
git clone http://gitlabsbnb.irbbarcelona.org/packages/chemical_checker.git
\end{lstlisting}

iii) Running the setup script:  \\

\begin{lstlisting}
cd chemical_checker && sh setup/setup_chemicalchecker.sh
\end{lstlisting}


\paragraph{2. Gathering bioactivity data} \leavevmode

To calculate type III signatures for any compound set of interest, it is necessary to collect all preexisting type II signatures (from other CC spaces) in a custom directory (from now on called \textit{custom\_path}). Such data can be directly downloaded from \href{https://chemicalchecker.com/downloads/signature2}{https://chemicalchecker.com/downloads/signature2}. For further details on the generation of type III signatures, please see \hyperref[Overview of the Chemical Checker data integration pipeline]{Overview of the Chemical Checker data integration pipeline}.


\paragraph{3. Running a Jupyter Notebook with the CC image} \leavevmode

We run a Jupyter Notebook within the CC image by executing the following command (which is an alias to run the \textit{setup/run\_chemicalchecker.sh} file from the cloned CC repository): \\

\begin{lstlisting}
chemcheck
\end{lstlisting}

Once the Jupyter Notebook is up and running, it is essential to import the CC package itself as well as all necessary external libraries to run the analyses (e.g. numpy). In addition, we can also specify the level of log outputs printed along the procedure. \\

\begin{lstlisting}
from chemicalchecker import ChemicalChecker
ChemicalChecker.set_verbosity('DEBUG') # CRITICAL, ERROR, WARN, INFO or DEBUG
\end{lstlisting}


\paragraph{4. Creating a CC instance} \leavevmode

A new CC instance is created with the directory chosen to allocate the results (\textit{local\_cc\_dir}). Additionally, we also need to specify the location of existing type II signatures (\textit{custom\_path}). \\

\begin{lstlisting}
local_cc_dir = './local_CC'
cc_local = ChemicalChecker(local_cc_dir, custom_data_path=custom_path)
\end{lstlisting}

\paragraph{5. Loading raw data} \leavevmode

To start the signaturization process, we first need to load a preprocessed version of the raw bioactivity data. Depending on the format of the data, the loading process may differ significantly. In the provided examples (Tasks 1-4), we have included cases in which the data is located in a CSV file and in a H5 file. Essentially, the starting data must consist in a well-defined bioactivity matrix (e.g. a pandas dataframe) containing N compounds (rows, indices) and M biological features (columns). 

\paragraph{6. Generating type 0 signatures} \leavevmode

Once the bioactivity data is loaded, we can generate type 0 signatures with the following code block. It is important to mention that we first need to define a \textit{dataset} name in a specific format specifying the CC space the data will be dumped in (e.g. B1.002, please see the \hyperref[Building_NEW_CC_BIOACTIVITY_SPACES]{Building new Chemical Checker bioactivity spaces} section). For further information about the generation of type 0 signatures, please see \hyperref[Overview of the Chemical Checker data integration pipeline]{Overview of the Chemical Checker data integration pipeline}. \\ \\

\begin{lstlisting}
dataset = 'B1.002' # e.g. B1.002, D1.002, D6.001, M1.001
sign0 = cc_local.signature(dataset,'sign0')
sign0.clear_all()
sign0.fit(X=df.values, keys=list(df.index), features=list(df.columns))
\end{lstlisting}


\paragraph{7. Generating type I signatures} \leavevmode

After obtaining type 0 signatures, we proceed to the generation of type I signatures. The code is straightforward and analogous to the previous step. Additionally, we also need to precompute compound nearest neighbors at type I signature level. For further information about the generation of type I signatures and the calculation of neighbors, please see \hyperref[Overview of the Chemical Checker data integration pipeline]{Overview of the Chemical Checker data integration pipeline}. \\

\begin{lstlisting}
# Type I signatures
sign0 = cc_local.signature(dataset, 'sign0')
sign1 = cc_local.signature(dataset, 'sign1')
sign1.clear_all()
sign1.fit(sign0)

# Neighbors
sign1 = cc_local.signature(dataset, 'sign1')
neig1 = cc_local.get_signature("neig1", "full", dataset)
neig1.clear_all()
neig1.fit(sign1)
\end{lstlisting}

\paragraph{8. Generating type II signatures} \leavevmode

Once we have type I signatures and neighbors calculated for our compound set, we can proceed to the generation of type II signatures. As seen in previous steps, the code is straightforward and follows the same architecture as before. For further information about the generation of type II signatures, please see \hyperref[Overview of the Chemical Checker data integration pipeline]{Overview of the Chemical Checker data integration pipeline}. \\

\begin{lstlisting}
sign1 = cc_local.get_signature('sign1', 'full', dataset)
neig1 = cc_local.get_signature('neig1', 'full', dataset)
sign2 = cc_local.signature(dataset, 'sign2')
sign2.clear_all()
sign2.fit(sign1, neig1, oos_predictor=False)
\end{lstlisting}


\paragraph{9. Generating type III signatures} \leavevmode

The last step in the signaturization process is the calculation of type III signatures. We first collect all type II signatures from the existing CC spaces along with type I and type II signatures for the extended or newly created space. Since the calculation of type III signatures is computationally expensive, we run it on an HPC cluster to enable CPU parallelization. Indeed, users may adapt the function \textit{fit\_hpc} with the specific parameters and configuration of their HPC cluster. Additionally, when creating a new CC space, it is important to check the overlap between the input dataset and the CC universe of small molecules, as poor overlaps between both sets may eventually result in unreliable type III signatures. Additionally, we calculate the chemical signatures (A1-5) for all those compounds that are not within the CC universe (\textit{complete\_universe=’full’}). For further information about the generation of type III signatures, please see \hyperref[Overview of the Chemical Checker data integration pipeline]{Overview of the Chemical Checker data integration pipeline}. The code below corresponds to the case example from Task 4 (M1.001) and it needs to be adapted to every particular exercise. For additional examples, please see our \href{https://gitlabsbnb.irbbarcelona.org/packages/protocols}{Gitlab repository}. \\

\begin{lstlisting}
dataset = 'M1.001'
sign3 = cc_local.signature(dataset, 'sign3')
sign3.clear_all()

sign2_list = list()
for ds in cc_local.coordinates:
    ds += '.001'
    sign2_list.append(cc_local.get_signature('sign2', 'full', ds))

sign2_list.append(cc_local.get_signature('sign2','full', dataset))
print(len(sign2_list))  # 26

sign1_self = cc_local.signature(dataset, 'sign1')
sign2_self = cc_local.signature(dataset, 'sign2')

# Specify CC_config file
os.environ['CC_CONFIG'] = '../cc_code/chemical_checker/setup/cc_config.json'

# Fit sign3 in the HPC machine
kwargs = {"cpu": 32, "mem_by_core": 1, "wait": True}
sign3.fit_hpc(sign2_list, sign2_self, sign1_self, sign2_universe=None, complete_universe="full", sign2_coverage=None, hpc_args=kwargs)


### CHECK OVERLAP ###
cc_universe = []
for dat in cc_local.datasets:
    if dat != dataset and dat.endswith('001'):
        cc_universe.extend(cc_local.get_signature('sign0', 'full', dat).keys)
cc_universe = set(cc_universe)

sign2 = cc_local.signature(dataset, 'sign2')
m1_molecules = set(sign2.keys)

print("Number of molecules in the CC universe: " + str(len(cc_universe)))
# 1009293
print("Number of molecules in M1 sign2: " + str(len(m1_molecules)))
# 200
print("Intersection CC & M1: " + str(len(cc_universe.intersection(m1_molecules))))
# 188
\end{lstlisting}


\paragraph{10. Generating diagnosis plots} \leavevmode

Finally, to visualize the flow of the data along the integration pipeline, we can generate diagnosis plots for all the newly obtained signatures (0, 1, 2 and 3) with the code provided below (replacing X by 0, 1, 2 or 3, depending on the signature type under analysis). For further information about the generation and interpretation of diagnosis plots, please see \hyperref[Overview of the Chemical Checker data integration pipeline]{Overview of the Chemical Checker data integration pipeline}). \\

\begin{lstlisting}
signX = cc_local.signature(dataset, 'signX')
diagX = sign.diagnosis(ref_cctype='sign0')
diagX.canvas(size='small', savefig=True, savefig_kwargs={'dpi': 300})
\end{lstlisting}
